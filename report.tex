%\documentstyle[a4paper,11pt]{jarticle}
\documentclass[a4paper,11pt]{jarticle}
\setlength{\topmargin}{-2.04cm}
\setlength{\oddsidemargin}{-1.04cm}
\setlength{\evensidemargin}{-1.04cm}
\setlength{\textwidth}{18cm}
\setlength{\textheight}{25cm}

\begin{document}
\thispagestyle{empty}
\begin{center}
\begin{Huge}
~\\
{\bf コンピュータ・サイエンス実験第一}\\
\vspace{1cm}
{\bf レポート課題J5}\\
\vspace{2cm}
{\bf 学籍番号 1211075  佐藤洋佑}\\
\end{Huge}
\end{center}
\vspace{17cm}
\begin{flushright}
{\bf 提出日 7月1日}\\
\end{flushright}
\newpage

\section{課題a}
\subsection{内容}
引き算、割り算、剰余演算も入れて見よ。ただし、乗除算、剰余演算は、加減算よりも演算順位が高くなるように
構文規則を変更すること。\\
\subsection{課題を解く方針}
\verb|T_SUB,T_DIV,T_REM|の3つ場合分けをし、引き算は足し算の例を参考に記述した。割り算と剰余演算は\verb|%rcx|に割る数を、
\verb|%rax|に割られる数を格納する。上位ビットにあたる\verb|%rdx|は0で初期化する。その後、商は\verb|%rax|に、
余りは\verb|%rdx|に格納される。\\
\subsection{lex/yacc/Cの記述}
ソースコードは以下の通り。なおlexファイル以外は変更箇所のみ記載する。\\
\begin{verbatim}
#----------------------------------lex--------------------------------------
alpha [a-zA-Z]
digit [0-9]
white [\n\t ]
%%
while                     { return WHILE; }
if                        { return IF; }
read                      { return READ; }
print                     { return PRINT; }
{alpha}({alpha}|{digit})* { return IDENT; }
{digit}+                  { return NUM; }
[-+()=;{}<>*/%]           { return yytext[0]; }
{white}                   { ; }
#----------------------------------yacc--------------------------------------
expr    : term                    { $$ = $1; }
        | expr '+' term           { $$ = node(T_ADD, $1, $3); }
        | expr '-' term           { $$ = node(T_SUB, $1, $3); }
        | expr '%' term           { $$ = node(T_REM, $1, $3); }
        ;
term    : prim                    { $$ = $1; }
        | term '*' prim           { $$ = node(T_MUL, $1, $3); }
        | term '/' prim           { $$ = node(T_DIV, $1, $3); }
        ;
#----------------------------------c--------------------------------------
    case T_SUB: emittree(ntab[i].left);
                emittree(ntab[i].right);
                printf(" popq %%rdx\n");
                printf(" popq %%rax\n");
                printf(" subq %%rdx,%%rax\n");
                printf(" pushq %%rax\n");
                break;
    case T_DIV: emittree(ntab[i].left);
                emittree(ntab[i].right);
                printf(" popq %%rcx\n");
                printf(" popq %%rax\n");
                printf(" movq $0,%%rdx\n");
                printf(" idivq %%rcx\n");
                printf(" pushq %%rax\n");
                break;
    case T_REM: emittree(ntab[i].left);
                emittree(ntab[i].right);
                printf(" popq %%rcx\n");
                printf(" popq %%rax\n");
                printf(" movq $0,%%rdx\n");
                printf(" idivq %%rcx\n");
                printf(" pushq %%rdx\n");
                break;
\end{verbatim}
追加した部分を説明する。lexはテキストと同じなので割愛する。yaccでは、まずtermという規則を作る。
乗除算を先に計算するように優先度を上げるためだ。それに伴ってexprの規則から乗除算を消している。
Cでは、まず引き算は\verb|T_SUB|のケースを作り、足し算を元にaddしていたものをsubしただけだ。
割り算と剰余演算は、方針に書いた通りに値をpopしたりmovで初期化を行なっている。
計算後に格納されているレジスタをそれぞれ表示している。\\
\subsection{実行結果}
実行するファイル内容は以下の通り。\\
\begin{verbatim}
main {
  read x;
  read y;
  print x + y;
  print x * y;
  print x - y;
  print x / y;
  print x % y;
  print x + y * (x + 1);
}
\end{verbatim}
実行結果は以下の通りになった。\\
\begin{verbatim}
> ./a.out
> 4
> 2
6
8
2
2
0
14
\end{verbatim}
\subsection{考察}
この方法で解いた利点としては、乗除算を優先するだけでなく、()のある計算を最優先にしているところだ。
欠点については、特にないと私は考えている。\\
\section{課題b}
\subsection{内容}
read文の拡張とprintx文の追加
\subsection{課題を解く方針}
まずread文の拡張だが、scanfで値を入力した後に追加で処理を行う。まずreadStatが入っているアドレスにscanfの戻り値を格納する。
次に入力されたものが文字かどうかを比較する。文字出会った場合はreadStatが入っているアドレスには、0が格納されているのでそのまま
にする。数字であっても範囲が決まっているのでその上限と下限を比較し、範囲外である場合は、readStatに0を格納する。
範囲内の数字であれば1が格納されている。printx文の追加は、yaccとlexにprintxを行うように処理を追加し、
Cでもprintと同じように記述することで実装する。\\
\subsection{lex/yacc/Cの記述}
ソースコードは以下の通り。なお、lexファイル以外は変更箇所のみ記載する。\\
\begin{verbatim}
#----------------------------------lex--------------------------------------
alpha [a-zA-Z]
digit [0-9]
white [\n\t ]
%%
do                        { return DO; }
while                     { return WHILE; }
if                        { return IF; }
read                      { return READ; }
print                     { return PRINT; }
printx                    { return PRINTX; }
{alpha}({alpha}|{digit})* { return IDENT; }
{digit}+                  { return NUM; }
[-+()=;{}<>*/%]           { return yytext[0]; }
{white}                   { ; }
#----------------------------------yacc--------------------------------------
stat    : var '=' expr ';'          { $$ = node(T_ASSIGN, $1, $3); }
        | READ var ';'              { $$ = node(T_READ, $2, 0); }
        | PRINT expr ';'            { $$ = node(T_PRINT, $2, 0); }
        | PRINTX expr ';'           { $$ = node(T_PRINTX, $2, 0); }
        | DO stat WHILE '(' cond ')'';'{ $$ = node(T_DO_WHILE,$5,$2); }
        | WHILE '(' cond ')' stat   { $$ = node(T_WHILE, $3, $5); }
        | IF '(' cond ')' stat      { $$ = node(T_IF, $3, $5); }
        | '{' stlist '}'            { $$ = $2; }
        ;
#----------------------------------c--------------------------------------
#define T_STLIST 1
#define T_ASSIGN 2
#define T_READ 3
#define T_PRINT 4
#define T_PRINTX 5
#define T_ADD 6
#define T_SUB 7
#define T_MUL 8
#define T_DIV 9
#define T_REM 10
#define T_NUM 11
#define T_VAR 12
#define T_WHILE 13
#define T_IF 14
#define T_LT 15
#define T_GT 16
#define T_DO_WHILE 17
< 中略 >
void dotree (i)
  int i;  {
    int stk;
    printf(" .section .rodata\n");
    printf(".Lprompt: .string \"> \"\n"); // プロンプト
    printf(".Lread:   .string \"%%ld\"\n"); // 読み取り用書式
    printf(".Lprint:  .string \"%%ld\\n\"\n"); // 書き取り用書式
    printf(".Lprintx: .string \"%%lx\\n\"\n"); // 16進数用書式
    printf(" .LreadClear: .string\"%%*s\"\n");  // 文字の入力時に値をクリアする用の書式
    printf(" .text\n");
    printf(".global main\n");
    printf("main:\n");
    printf(" pushq %%rbp\n");
    printf(" movq %%rsp,%%rbp\n");
    stk = (8*stabuse + 15) / 16; /* 変数の個数*8 で16 の倍数へ切り上げ*/
    stk *= 16;
    printf(" subq $%d,%%rsp\n", stk);
    emittree(i);
    printf(" leave\n");
    printf(" ret\n");
  }
< 中略 >
    case T_READ:  printf(" movq $.Lprompt,%%rdi\n");
                  printf(" movq $0,%%rax\n");
                  printf(" call printf\n");
                  printf(" leaq %d(%%rbp),%%rsi\n", -(ntab[i].left+1)*8);
                  printf(" movq $.Lread,%%rdi\n");
                  printf(" call scanf\n");
                  for(num = 0;num < stabuse; ++num){
                    if(strcmp(stab[num].name,"readStat") == 0){
                      printf(" pushq %%rax\n");
                      printf(" popq %d(%%rbp)\n",-(num+1)*8);
                      break;
                    }
                  }
                  l = labelno++;
                  labelno += 3;
                  printf(" cmp $0,%%rax\n");
                  printf(" jne .L%d\n",l);
                  printf(" movq $0,%%rsi\n");
                  printf(" movq $.LreadClear,%%rdi\n");
                  printf(" call scanf\n");
                  printf(" .L%d:\n",l);
                  printf(" pushq %d(%%rbp)\n",-(ntab[i].left+1)*8);
                  printf(" popq %%rsi\n");
                  printf(" movq $9223372036854775807,%%rax\n");
                  printf(" cmp %%rsi,%%rax\n");
                  printf(" je .L%d\n",l+1);
                  printf(" movq $-9223372036854775808,%%rax\n");
                  printf(" cmp %%rsi,%%rax\n");
                  printf(" jne .L%d\n",l+2);
                  printf(" .L%d:\n",l+1);
                  for(num = 0;num < stabuse; ++num){
                    if(strcmp(stab[num].name,"readStat") == 0){
                      printf(" pushq $0\n");
                      printf(" popq %d(%%rbp)\n",-(num+1)*8);
                      break;
                    }
                  }
                  printf(" .L%d:\n",l+2);
                  break;
    case T_PRINTX:  emittree(ntab[i].left);
                    printf(" popq %%rsi\n");
                    printf(" movq $.Lprintx,%%rdi\n");
                    printf(" movq $0,%%rax\n");
                    printf(" call printf\n"); break;
\end{verbatim}
追加した部分を説明する。lexでは、printxがきたらPRINTXを返すように追加した。yaccでは、PRINTを参考にPRINTXの記述をした。
Cでは、まず、read文でラベルを3つ使用している。L1では、数字であった場合の処理、L2では数字が上限(下限)以上だった場合、
readStatに0を格納する処理、L3では範囲内の数字が入力された時の処理とした。scanfをした後for文により、
readStatの入っているアドレスを探し、見つかった場合、\verb|pushq %rax|として戻り値をプッシュし、
\verb|printf("popq %d(%%rbp)\n",-(num+1)*8)|としてreadStatにscanfの戻り値を格納する。文字が入力された場合、
\verb|%rdi|には余分な文字が残っているので、dotreeに\verb|.LreadClear|に\verb|%*s|をprintfするように書式を作った。
ラベルL1では上限、下限を比較し、0になった場合ラベルL2に飛ぶようにする。そうではなかった場合はラベルL3に飛ぶようにする。
ラベルL2ではreadStatに戻り値を格納した時と同じようにして今度は0を格納する。ラベルL3はうまく行った時の処理なので何もしない。
また、printfで\verb|%lx|をするためにdotreeで、\verb|.Lprintx|として、\verb|%lx\n|の書式を追加した。\\
\subsection{実行結果}
実行するファイルの内容は以下の通り。なおこの問題では課題cの処理も追加されたものを使っているが、そちらの説明は
課題cで改めて説明する。\\
\begin{verbatim}
main {
  read x;
  y = 1;
  while(readStat > 0){
    print x;
    y = y * x;
    read x;
  }
  print y;
  printx y;
}
\end{verbatim}
実行結果は以下の通り。\\
\begin{verbatim}
> ./a.out
> 3
3
> 4
4
> a
12
c
\end{verbatim}
\subsection{考察}
この方法で解いた場合、欠点が1つある。それは上限(下限)値を入力した場合も、リミットオーバー扱いになって条件から外れる事だ。
しかし、上限や下限を超えると強制で上限(下限)値になってしまうので、それを省く処理が思いつかなかった。printxについては、
この方法がわかりやすいと思う。\\
\section{課題c}
\subsection{内容}
while文とdo-while文の実装。\\
\subsection{課題を解く方針}
まずwhile文では、ラベルを2つ用意し、条件を満たしている場合の処理のラベルと条件を満たさなくなった場合の処理を作る。
do-while文では、ほとんどwhileと同じだが、実行文を実行する位置を変える。\\
\subsection{lex/yacc/Cの記述}
ソースコードは以下の通り。\\
\begin{verbatim}
#----------------------------------lex--------------------------------------
alpha [a-zA-Z]
digit [0-9]
white [\n\t ]
%%
do                        { return DO; }
while                     { return WHILE; }
if                        { return IF; }
read                      { return READ; }
print                     { return PRINT; }
{alpha}({alpha}|{digit})* { return IDENT; }
{digit}+                  { return NUM; }
[-+()=;{}<>*/%]           { return yytext[0]; }
{white}                   { ; }
#----------------------------------yacc--------------------------------------
stat    : var '=' expr ';'          { $$ = node(T_ASSIGN, $1, $3); }
        | READ var ';'              { $$ = node(T_READ, $2, 0); }
        | PRINT expr ';'            { $$ = node(T_PRINT, $2, 0); }
        | DO stat WHILE '(' cond ')'';'{ $$ = node(T_DO_WHILE,$5,$2); }
        | WHILE '(' cond ')' stat   { $$ = node(T_WHILE, $3, $5); }
        | IF '(' cond ')' stat      { $$ = node(T_IF, $3, $5); }
        | '{' stlist '}'            { $$ = $2; }
        ;
#----------------------------------c--------------------------------------
#define T_STLIST 1
#define T_ASSIGN 2
#define T_READ 3
#define T_PRINT 4
#define T_ADD 5
#define T_SUB 6
#define T_MUL 7
#define T_DIV 8
#define T_REM 9
#define T_NUM 10
#define T_VAR 11
#define T_WHILE 12
#define T_IF 13
#define T_LT 14
#define T_GT 15
#define T_DO_WHILE 16
< 中略 >
    case T_WHILE: l = labelno++;
                  labelno += 2;
                  printf(" .L%d:\n",l);
                  emittree(ntab[i].left);
                  printf(" .L%d\n",l+1);
                  emittree(ntab[i].right);
                  printf(" jmp .L%d\n",l);
                  printf(" .L%d:\n",l+1); break;
    case T_DO_WHILE:  l = labelno++;
                      labelno += 2;
                      printf(" .L%d:\n",l);
                      emittree(ntab[i].right);
                      emittree(ntab[i].left);
                      printf(" .L%d\n",l+1);
                      printf(" jmp .L%d\n",l);
                      printf(" .L%d:\n",l+1); break;
\end{verbatim}
lexでは、whileが来たらWHILEを返すように、do-whileではdoが先にくるのでDOを返すようにした。yaccではdo-whileの処理を先に
行なってからwhileの処理を記述した。do-whileでは先にdoが来るので、不具合を防ぐためにこのようにした。
Cでは、まず\verb|T_DO_WHILE|を新たにdefineして、emittree関数ではwhileとdo-whileの処理を追加した。
whileでは、ラベルL1の中で\verb|emittree(ntab[i].left);|とすることで条件を満たしているかを判断し、
満たしていない場合は、ラベルL2に飛ぶ処理をする。条件を満たしている場合は、\verb|emittree(ntab[i].right);|で実行文を読み込む。
その後ラベルL1に飛んで条件を満たしている間この処理をする。do-whileの場合、必ず1度は処理をされるので、処理の順番を変える。
具体的には、\verb|emittree(ntab[i].right);|の位置を\verb|emittree(ntab[i].left);|の前に持ってくる事だ。
こうすることで、条件を見る前に1度は実行されるようになる。あとはwhileの処理と同じである。\\
\subsection{実行結果}
実行するファイルの内容は以下の通り。\\
\begin{verbatim}
main {
  read x;
  read i;
  y = 1;
  tmp = i;
  while(i < 3){
    y = y * x;
    i = i + 1;
  }
  print y;
  y = 1;
  i = tmp;
  do{
    y = y * x;
    i = i + 1;
  }while(i < 3);
  print y;
}
\end{verbatim}
実行結果は以下の通りである。\\
\begin{verbatim}
> ./a.out 
> 4
> 1
16
16
> ./a.out 
> 4 
> 4
1
4
\end{verbatim}
\subsection{考察}
この方法であれば、whileとdo-whileが両立してあってもしっかり処理を行う事ができる。他の解法に関しては浮かばなかったが、
この方法が簡潔であると思う。
\end{document}
